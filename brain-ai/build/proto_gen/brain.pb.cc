// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brain.proto

#include "brain.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace brain {
PROTOBUF_CONSTEXPR HealthReq::HealthReq(
    ::_pbi::ConstantInitialized) {}
struct HealthReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthReqDefaultTypeInternal() {}
  union {
    HealthReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthReqDefaultTypeInternal _HealthReq_default_instance_;
PROTOBUF_CONSTEXPR HealthResp::HealthResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uptime_ms_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HealthRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthRespDefaultTypeInternal() {}
  union {
    HealthResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthRespDefaultTypeInternal _HealthResp_default_instance_;
PROTOBUF_CONSTEXPR StepReq::StepReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_)*/{}
  , /*decltype(_impl_.context_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reward_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StepReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StepReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StepReqDefaultTypeInternal() {}
  union {
    StepReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StepReqDefaultTypeInternal _StepReq_default_instance_;
PROTOBUF_CONSTEXPR StepResp::StepResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.qw_state_)*/{}
  , /*decltype(_impl_.memory_stats_)*/nullptr
  , /*decltype(_impl_.entropy_)*/0
  , /*decltype(_impl_.total_collapses_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StepRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StepRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StepRespDefaultTypeInternal() {}
  union {
    StepResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StepRespDefaultTypeInternal _StepResp_default_instance_;
PROTOBUF_CONSTEXPR StatsReq::StatsReq(
    ::_pbi::ConstantInitialized) {}
struct StatsReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsReqDefaultTypeInternal() {}
  union {
    StatsReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsReqDefaultTypeInternal _StatsReq_default_instance_;
PROTOBUF_CONSTEXPR StatsResp_MetricsEntry_DoNotUse::StatsResp_MetricsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct StatsResp_MetricsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsResp_MetricsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsResp_MetricsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    StatsResp_MetricsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsResp_MetricsEntry_DoNotUseDefaultTypeInternal _StatsResp_MetricsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR StatsResp::StatsResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metrics_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.memory_stats_)*/nullptr
  , /*decltype(_impl_.graph_stats_)*/nullptr
  , /*decltype(_impl_.entropy_)*/0
  , /*decltype(_impl_.total_collapses_)*/int64_t{0}
  , /*decltype(_impl_.purity_)*/0
  , /*decltype(_impl_.dimension_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsRespDefaultTypeInternal() {}
  union {
    StatsResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsRespDefaultTypeInternal _StatsResp_default_instance_;
PROTOBUF_CONSTEXPR EmbedReq::EmbedReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmbedReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedReqDefaultTypeInternal() {}
  union {
    EmbedReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedReqDefaultTypeInternal _EmbedReq_default_instance_;
PROTOBUF_CONSTEXPR EmbedResp::EmbedResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.embedding_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmbedRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedRespDefaultTypeInternal() {}
  union {
    EmbedResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedRespDefaultTypeInternal _EmbedResp_default_instance_;
PROTOBUF_CONSTEXPR UpsertReq::UpsertReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/{}
  , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_.vectors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpsertReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpsertReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpsertReqDefaultTypeInternal() {}
  union {
    UpsertReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpsertReqDefaultTypeInternal _UpsertReq_default_instance_;
PROTOBUF_CONSTEXPR EmbedVector::EmbedVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmbedVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmbedVectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmbedVectorDefaultTypeInternal() {}
  union {
    EmbedVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbedVectorDefaultTypeInternal _EmbedVector_default_instance_;
PROTOBUF_CONSTEXPR UpsertResp::UpsertResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpsertRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpsertRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpsertRespDefaultTypeInternal() {}
  union {
    UpsertResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpsertRespDefaultTypeInternal _UpsertResp_default_instance_;
PROTOBUF_CONSTEXPR RecallReq::RecallReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.query_)*/{}
  , /*decltype(_impl_.filters_)*/{}
  , /*decltype(_impl_.topk_)*/0
  , /*decltype(_impl_.use_graph_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecallReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecallReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecallReqDefaultTypeInternal() {}
  union {
    RecallReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecallReqDefaultTypeInternal _RecallReq_default_instance_;
PROTOBUF_CONSTEXPR FilterPredicate::FilterPredicate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.op_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FilterPredicateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterPredicateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterPredicateDefaultTypeInternal() {}
  union {
    FilterPredicate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterPredicateDefaultTypeInternal _FilterPredicate_default_instance_;
PROTOBUF_CONSTEXPR RecallResp::RecallResp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/{}
  , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_.distances_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecallRespDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecallRespDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecallRespDefaultTypeInternal() {}
  union {
    RecallResp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecallRespDefaultTypeInternal _RecallResp_default_instance_;
PROTOBUF_CONSTEXPR MemoryStats::MemoryStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.total_items_)*/int64_t{0}
  , /*decltype(_impl_.hot_items_)*/int64_t{0}
  , /*decltype(_impl_.warm_items_)*/int64_t{0}
  , /*decltype(_impl_.cold_items_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MemoryStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MemoryStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MemoryStatsDefaultTypeInternal() {}
  union {
    MemoryStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemoryStatsDefaultTypeInternal _MemoryStats_default_instance_;
PROTOBUF_CONSTEXPR GraphStats::GraphStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/int64_t{0}
  , /*decltype(_impl_.edges_)*/int64_t{0}
  , /*decltype(_impl_.avg_degree_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GraphStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphStatsDefaultTypeInternal() {}
  union {
    GraphStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphStatsDefaultTypeInternal _GraphStats_default_instance_;
}  // namespace brain
static ::_pb::Metadata file_level_metadata_brain_2eproto[17];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_brain_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_brain_2eproto = nullptr;

const uint32_t TableStruct_brain_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::HealthReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::HealthResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::HealthResp, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::brain::HealthResp, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::brain::HealthResp, _impl_.uptime_ms_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::StepReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::StepReq, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::brain::StepReq, _impl_.reward_),
  PROTOBUF_FIELD_OFFSET(::brain::StepReq, _impl_.context_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::StepResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::StepResp, _impl_.entropy_),
  PROTOBUF_FIELD_OFFSET(::brain::StepResp, _impl_.total_collapses_),
  PROTOBUF_FIELD_OFFSET(::brain::StepResp, _impl_.qw_state_),
  PROTOBUF_FIELD_OFFSET(::brain::StepResp, _impl_.memory_stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::StatsReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp_MetricsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp_MetricsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp_MetricsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp_MetricsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.entropy_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.total_collapses_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.dimension_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.purity_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.memory_stats_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.graph_stats_),
  PROTOBUF_FIELD_OFFSET(::brain::StatsResp, _impl_.metrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedReq, _impl_.text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedResp, _impl_.embedding_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::UpsertReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::UpsertReq, _impl_.ids_),
  PROTOBUF_FIELD_OFFSET(::brain::UpsertReq, _impl_.vectors_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::EmbedVector, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::UpsertResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::UpsertResp, _impl_.count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::RecallReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::RecallReq, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::brain::RecallReq, _impl_.topk_),
  PROTOBUF_FIELD_OFFSET(::brain::RecallReq, _impl_.filters_),
  PROTOBUF_FIELD_OFFSET(::brain::RecallReq, _impl_.use_graph_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::FilterPredicate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::FilterPredicate, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::brain::FilterPredicate, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::brain::FilterPredicate, _impl_.value_text_),
  PROTOBUF_FIELD_OFFSET(::brain::FilterPredicate, _impl_.value_num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::RecallResp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::RecallResp, _impl_.ids_),
  PROTOBUF_FIELD_OFFSET(::brain::RecallResp, _impl_.distances_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::MemoryStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::MemoryStats, _impl_.total_items_),
  PROTOBUF_FIELD_OFFSET(::brain::MemoryStats, _impl_.hot_items_),
  PROTOBUF_FIELD_OFFSET(::brain::MemoryStats, _impl_.warm_items_),
  PROTOBUF_FIELD_OFFSET(::brain::MemoryStats, _impl_.cold_items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brain::GraphStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brain::GraphStats, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::brain::GraphStats, _impl_.edges_),
  PROTOBUF_FIELD_OFFSET(::brain::GraphStats, _impl_.avg_degree_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::brain::HealthReq)},
  { 6, -1, -1, sizeof(::brain::HealthResp)},
  { 15, -1, -1, sizeof(::brain::StepReq)},
  { 24, -1, -1, sizeof(::brain::StepResp)},
  { 34, -1, -1, sizeof(::brain::StatsReq)},
  { 40, 48, -1, sizeof(::brain::StatsResp_MetricsEntry_DoNotUse)},
  { 50, -1, -1, sizeof(::brain::StatsResp)},
  { 63, -1, -1, sizeof(::brain::EmbedReq)},
  { 70, -1, -1, sizeof(::brain::EmbedResp)},
  { 77, -1, -1, sizeof(::brain::UpsertReq)},
  { 85, -1, -1, sizeof(::brain::EmbedVector)},
  { 92, -1, -1, sizeof(::brain::UpsertResp)},
  { 99, -1, -1, sizeof(::brain::RecallReq)},
  { 109, -1, -1, sizeof(::brain::FilterPredicate)},
  { 119, -1, -1, sizeof(::brain::RecallResp)},
  { 127, -1, -1, sizeof(::brain::MemoryStats)},
  { 137, -1, -1, sizeof(::brain::GraphStats)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::brain::_HealthReq_default_instance_._instance,
  &::brain::_HealthResp_default_instance_._instance,
  &::brain::_StepReq_default_instance_._instance,
  &::brain::_StepResp_default_instance_._instance,
  &::brain::_StatsReq_default_instance_._instance,
  &::brain::_StatsResp_MetricsEntry_DoNotUse_default_instance_._instance,
  &::brain::_StatsResp_default_instance_._instance,
  &::brain::_EmbedReq_default_instance_._instance,
  &::brain::_EmbedResp_default_instance_._instance,
  &::brain::_UpsertReq_default_instance_._instance,
  &::brain::_EmbedVector_default_instance_._instance,
  &::brain::_UpsertResp_default_instance_._instance,
  &::brain::_RecallReq_default_instance_._instance,
  &::brain::_FilterPredicate_default_instance_._instance,
  &::brain::_RecallResp_default_instance_._instance,
  &::brain::_MemoryStats_default_instance_._instance,
  &::brain::_GraphStats_default_instance_._instance,
};

const char descriptor_table_protodef_brain_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013brain.proto\022\005brain\"\013\n\tHealthReq\"@\n\nHea"
  "lthResp\022\016\n\006status\030\001 \001(\t\022\017\n\007version\030\002 \001(\t"
  "\022\021\n\tuptime_ms\030\003 \001(\003\"9\n\007StepReq\022\r\n\005input\030"
  "\001 \003(\001\022\016\n\006reward\030\002 \001(\001\022\017\n\007context\030\003 \001(\t\"p"
  "\n\010StepResp\022\017\n\007entropy\030\001 \001(\001\022\027\n\017total_col"
  "lapses\030\002 \001(\003\022\020\n\010qw_state\030\003 \003(\001\022(\n\014memory"
  "_stats\030\004 \001(\0132\022.brain.MemoryStats\"\n\n\010Stat"
  "sReq\"\212\002\n\tStatsResp\022\017\n\007entropy\030\001 \001(\001\022\027\n\017t"
  "otal_collapses\030\002 \001(\003\022\021\n\tdimension\030\003 \001(\005\022"
  "\016\n\006purity\030\004 \001(\001\022(\n\014memory_stats\030\005 \001(\0132\022."
  "brain.MemoryStats\022&\n\013graph_stats\030\006 \001(\0132\021"
  ".brain.GraphStats\022.\n\007metrics\030\007 \003(\0132\035.bra"
  "in.StatsResp.MetricsEntry\032.\n\014MetricsEntr"
  "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001\"\030\n\010Emb"
  "edReq\022\014\n\004text\030\001 \001(\t\"\036\n\tEmbedResp\022\021\n\tembe"
  "dding\030\001 \003(\002\"=\n\tUpsertReq\022\013\n\003ids\030\001 \003(\003\022#\n"
  "\007vectors\030\002 \003(\0132\022.brain.EmbedVector\"\033\n\013Em"
  "bedVector\022\014\n\004data\030\001 \003(\002\"\033\n\nUpsertResp\022\r\n"
  "\005count\030\001 \001(\005\"d\n\tRecallReq\022\r\n\005query\030\001 \003(\002"
  "\022\014\n\004topk\030\002 \001(\005\022\'\n\007filters\030\003 \003(\0132\026.brain."
  "FilterPredicate\022\021\n\tuse_graph\030\004 \001(\010\"Q\n\017Fi"
  "lterPredicate\022\013\n\003key\030\001 \001(\t\022\n\n\002op\030\002 \001(\t\022\022"
  "\n\nvalue_text\030\003 \001(\t\022\021\n\tvalue_num\030\004 \001(\001\",\n"
  "\nRecallResp\022\013\n\003ids\030\001 \003(\003\022\021\n\tdistances\030\002 "
  "\003(\002\"]\n\013MemoryStats\022\023\n\013total_items\030\001 \001(\003\022"
  "\021\n\thot_items\030\002 \001(\003\022\022\n\nwarm_items\030\003 \001(\003\022\022"
  "\n\ncold_items\030\004 \001(\003\">\n\nGraphStats\022\r\n\005node"
  "s\030\001 \001(\003\022\r\n\005edges\030\002 \001(\003\022\022\n\navg_degree\030\003 \001"
  "(\0012\235\002\n\005Brain\022\'\n\004Step\022\016.brain.StepReq\032\017.b"
  "rain.StepResp\022-\n\010GetStats\022\017.brain.StatsR"
  "eq\032\020.brain.StatsResp\022*\n\005Embed\022\017.brain.Em"
  "bedReq\032\020.brain.EmbedResp\022-\n\006Upsert\022\020.bra"
  "in.UpsertReq\032\021.brain.UpsertResp\022-\n\006Recal"
  "l\022\020.brain.RecallReq\032\021.brain.RecallResp\0222"
  "\n\013HealthCheck\022\020.brain.HealthReq\032\021.brain."
  "HealthRespb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_brain_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_brain_2eproto = {
    false, false, 1418, descriptor_table_protodef_brain_2eproto,
    "brain.proto",
    &descriptor_table_brain_2eproto_once, nullptr, 0, 17,
    schemas, file_default_instances, TableStruct_brain_2eproto::offsets,
    file_level_metadata_brain_2eproto, file_level_enum_descriptors_brain_2eproto,
    file_level_service_descriptors_brain_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_brain_2eproto_getter() {
  return &descriptor_table_brain_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_brain_2eproto(&descriptor_table_brain_2eproto);
namespace brain {

// ===================================================================

class HealthReq::_Internal {
 public:
};

HealthReq::HealthReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:brain.HealthReq)
}
HealthReq::HealthReq(const HealthReq& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HealthReq* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.HealthReq)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HealthReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HealthReq::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HealthReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[0]);
}

// ===================================================================

class HealthResp::_Internal {
 public:
};

HealthResp::HealthResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.HealthResp)
}
HealthResp::HealthResp(const HealthResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HealthResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_ms_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.uptime_ms_ = from._impl_.uptime_ms_;
  // @@protoc_insertion_point(copy_constructor:brain.HealthResp)
}

inline void HealthResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_ms_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HealthResp::~HealthResp() {
  // @@protoc_insertion_point(destructor:brain.HealthResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HealthResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_.Destroy();
  _impl_.version_.Destroy();
}

void HealthResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HealthResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.HealthResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  _impl_.uptime_ms_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HealthResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.HealthResp.status"));
        } else
          goto handle_unusual;
        continue;
      // string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.HealthResp.version"));
        } else
          goto handle_unusual;
        continue;
      // int64 uptime_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.uptime_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HealthResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.HealthResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.HealthResp.status");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status(), target);
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.HealthResp.version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // int64 uptime_ms = 3;
  if (this->_internal_uptime_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_uptime_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.HealthResp)
  return target;
}

size_t HealthResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.HealthResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string status = 1;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  // string version = 2;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // int64 uptime_ms = 3;
  if (this->_internal_uptime_ms() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_ms());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HealthResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HealthResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HealthResp::GetClassData() const { return &_class_data_; }


void HealthResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HealthResp*>(&to_msg);
  auto& from = static_cast<const HealthResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.HealthResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_uptime_ms() != 0) {
    _this->_internal_set_uptime_ms(from._internal_uptime_ms());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HealthResp::CopyFrom(const HealthResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.HealthResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthResp::IsInitialized() const {
  return true;
}

void HealthResp::InternalSwap(HealthResp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  swap(_impl_.uptime_ms_, other->_impl_.uptime_ms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HealthResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[1]);
}

// ===================================================================

class StepReq::_Internal {
 public:
};

StepReq::StepReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.StepReq)
}
StepReq::StepReq(const StepReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StepReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){from._impl_.input_}
    , decltype(_impl_.context_){}
    , decltype(_impl_.reward_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.context_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.context_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_context().empty()) {
    _this->_impl_.context_.Set(from._internal_context(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.reward_ = from._impl_.reward_;
  // @@protoc_insertion_point(copy_constructor:brain.StepReq)
}

inline void StepReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){arena}
    , decltype(_impl_.context_){}
    , decltype(_impl_.reward_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.context_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.context_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StepReq::~StepReq() {
  // @@protoc_insertion_point(destructor:brain.StepReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StepReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.input_.~RepeatedField();
  _impl_.context_.Destroy();
}

void StepReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StepReq::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.StepReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.input_.Clear();
  _impl_.context_.ClearToEmpty();
  _impl_.reward_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StepReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double input = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_input(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_input(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reward = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.reward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string context = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_context();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.StepReq.context"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StepReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.StepReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double input = 1;
  if (this->_internal_input_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_input(), target);
  }

  // double reward = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reward = this->_internal_reward();
  uint64_t raw_reward;
  memcpy(&raw_reward, &tmp_reward, sizeof(tmp_reward));
  if (raw_reward != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_reward(), target);
  }

  // string context = 3;
  if (!this->_internal_context().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_context().data(), static_cast<int>(this->_internal_context().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.StepReq.context");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_context(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.StepReq)
  return target;
}

size_t StepReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.StepReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double input = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_input_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string context = 3;
  if (!this->_internal_context().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_context());
  }

  // double reward = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reward = this->_internal_reward();
  uint64_t raw_reward;
  memcpy(&raw_reward, &tmp_reward, sizeof(tmp_reward));
  if (raw_reward != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StepReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StepReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StepReq::GetClassData() const { return &_class_data_; }


void StepReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StepReq*>(&to_msg);
  auto& from = static_cast<const StepReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.StepReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  if (!from._internal_context().empty()) {
    _this->_internal_set_context(from._internal_context());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reward = from._internal_reward();
  uint64_t raw_reward;
  memcpy(&raw_reward, &tmp_reward, sizeof(tmp_reward));
  if (raw_reward != 0) {
    _this->_internal_set_reward(from._internal_reward());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StepReq::CopyFrom(const StepReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.StepReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepReq::IsInitialized() const {
  return true;
}

void StepReq::InternalSwap(StepReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.context_, lhs_arena,
      &other->_impl_.context_, rhs_arena
  );
  swap(_impl_.reward_, other->_impl_.reward_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StepReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[2]);
}

// ===================================================================

class StepResp::_Internal {
 public:
  static const ::brain::MemoryStats& memory_stats(const StepResp* msg);
};

const ::brain::MemoryStats&
StepResp::_Internal::memory_stats(const StepResp* msg) {
  return *msg->_impl_.memory_stats_;
}
StepResp::StepResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.StepResp)
}
StepResp::StepResp(const StepResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StepResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.qw_state_){from._impl_.qw_state_}
    , decltype(_impl_.memory_stats_){nullptr}
    , decltype(_impl_.entropy_){}
    , decltype(_impl_.total_collapses_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_memory_stats()) {
    _this->_impl_.memory_stats_ = new ::brain::MemoryStats(*from._impl_.memory_stats_);
  }
  ::memcpy(&_impl_.entropy_, &from._impl_.entropy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_collapses_) -
    reinterpret_cast<char*>(&_impl_.entropy_)) + sizeof(_impl_.total_collapses_));
  // @@protoc_insertion_point(copy_constructor:brain.StepResp)
}

inline void StepResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.qw_state_){arena}
    , decltype(_impl_.memory_stats_){nullptr}
    , decltype(_impl_.entropy_){0}
    , decltype(_impl_.total_collapses_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StepResp::~StepResp() {
  // @@protoc_insertion_point(destructor:brain.StepResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StepResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.qw_state_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.memory_stats_;
}

void StepResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StepResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.StepResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.qw_state_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.memory_stats_ != nullptr) {
    delete _impl_.memory_stats_;
  }
  _impl_.memory_stats_ = nullptr;
  ::memset(&_impl_.entropy_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_collapses_) -
      reinterpret_cast<char*>(&_impl_.entropy_)) + sizeof(_impl_.total_collapses_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StepResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double entropy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.entropy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 total_collapses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_collapses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double qw_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_qw_state(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 25) {
          _internal_add_qw_state(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .brain.MemoryStats memory_stats = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_memory_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StepResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.StepResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double entropy = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = this->_internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_entropy(), target);
  }

  // int64 total_collapses = 2;
  if (this->_internal_total_collapses() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_total_collapses(), target);
  }

  // repeated double qw_state = 3;
  if (this->_internal_qw_state_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_qw_state(), target);
  }

  // .brain.MemoryStats memory_stats = 4;
  if (this->_internal_has_memory_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::memory_stats(this),
        _Internal::memory_stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.StepResp)
  return target;
}

size_t StepResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.StepResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double qw_state = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_qw_state_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .brain.MemoryStats memory_stats = 4;
  if (this->_internal_has_memory_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.memory_stats_);
  }

  // double entropy = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = this->_internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    total_size += 1 + 8;
  }

  // int64 total_collapses = 2;
  if (this->_internal_total_collapses() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_collapses());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StepResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StepResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StepResp::GetClassData() const { return &_class_data_; }


void StepResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StepResp*>(&to_msg);
  auto& from = static_cast<const StepResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.StepResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.qw_state_.MergeFrom(from._impl_.qw_state_);
  if (from._internal_has_memory_stats()) {
    _this->_internal_mutable_memory_stats()->::brain::MemoryStats::MergeFrom(
        from._internal_memory_stats());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = from._internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    _this->_internal_set_entropy(from._internal_entropy());
  }
  if (from._internal_total_collapses() != 0) {
    _this->_internal_set_total_collapses(from._internal_total_collapses());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StepResp::CopyFrom(const StepResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.StepResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepResp::IsInitialized() const {
  return true;
}

void StepResp::InternalSwap(StepResp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.qw_state_.InternalSwap(&other->_impl_.qw_state_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StepResp, _impl_.total_collapses_)
      + sizeof(StepResp::_impl_.total_collapses_)
      - PROTOBUF_FIELD_OFFSET(StepResp, _impl_.memory_stats_)>(
          reinterpret_cast<char*>(&_impl_.memory_stats_),
          reinterpret_cast<char*>(&other->_impl_.memory_stats_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StepResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[3]);
}

// ===================================================================

class StatsReq::_Internal {
 public:
};

StatsReq::StatsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:brain.StatsReq)
}
StatsReq::StatsReq(const StatsReq& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  StatsReq* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.StatsReq)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsReq::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata StatsReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[4]);
}

// ===================================================================

StatsResp_MetricsEntry_DoNotUse::StatsResp_MetricsEntry_DoNotUse() {}
StatsResp_MetricsEntry_DoNotUse::StatsResp_MetricsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void StatsResp_MetricsEntry_DoNotUse::MergeFrom(const StatsResp_MetricsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata StatsResp_MetricsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[5]);
}

// ===================================================================

class StatsResp::_Internal {
 public:
  static const ::brain::MemoryStats& memory_stats(const StatsResp* msg);
  static const ::brain::GraphStats& graph_stats(const StatsResp* msg);
};

const ::brain::MemoryStats&
StatsResp::_Internal::memory_stats(const StatsResp* msg) {
  return *msg->_impl_.memory_stats_;
}
const ::brain::GraphStats&
StatsResp::_Internal::graph_stats(const StatsResp* msg) {
  return *msg->_impl_.graph_stats_;
}
StatsResp::StatsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &StatsResp::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:brain.StatsResp)
}
StatsResp::StatsResp(const StatsResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metrics_)*/{}
    , decltype(_impl_.memory_stats_){nullptr}
    , decltype(_impl_.graph_stats_){nullptr}
    , decltype(_impl_.entropy_){}
    , decltype(_impl_.total_collapses_){}
    , decltype(_impl_.purity_){}
    , decltype(_impl_.dimension_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.metrics_.MergeFrom(from._impl_.metrics_);
  if (from._internal_has_memory_stats()) {
    _this->_impl_.memory_stats_ = new ::brain::MemoryStats(*from._impl_.memory_stats_);
  }
  if (from._internal_has_graph_stats()) {
    _this->_impl_.graph_stats_ = new ::brain::GraphStats(*from._impl_.graph_stats_);
  }
  ::memcpy(&_impl_.entropy_, &from._impl_.entropy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dimension_) -
    reinterpret_cast<char*>(&_impl_.entropy_)) + sizeof(_impl_.dimension_));
  // @@protoc_insertion_point(copy_constructor:brain.StatsResp)
}

inline void StatsResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metrics_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.memory_stats_){nullptr}
    , decltype(_impl_.graph_stats_){nullptr}
    , decltype(_impl_.entropy_){0}
    , decltype(_impl_.total_collapses_){int64_t{0}}
    , decltype(_impl_.purity_){0}
    , decltype(_impl_.dimension_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsResp::~StatsResp() {
  // @@protoc_insertion_point(destructor:brain.StatsResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void StatsResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metrics_.Destruct();
  _impl_.metrics_.~MapField();
  if (this != internal_default_instance()) delete _impl_.memory_stats_;
  if (this != internal_default_instance()) delete _impl_.graph_stats_;
}

void StatsResp::ArenaDtor(void* object) {
  StatsResp* _this = reinterpret_cast< StatsResp* >(object);
  _this->_impl_.metrics_.Destruct();
}
void StatsResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.StatsResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metrics_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.memory_stats_ != nullptr) {
    delete _impl_.memory_stats_;
  }
  _impl_.memory_stats_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.graph_stats_ != nullptr) {
    delete _impl_.graph_stats_;
  }
  _impl_.graph_stats_ = nullptr;
  ::memset(&_impl_.entropy_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dimension_) -
      reinterpret_cast<char*>(&_impl_.entropy_)) + sizeof(_impl_.dimension_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double entropy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.entropy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 total_collapses = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_collapses_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dimension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double purity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.purity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .brain.MemoryStats memory_stats = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_memory_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .brain.GraphStats graph_stats = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_graph_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> metrics = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.metrics_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.StatsResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double entropy = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = this->_internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_entropy(), target);
  }

  // int64 total_collapses = 2;
  if (this->_internal_total_collapses() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_total_collapses(), target);
  }

  // int32 dimension = 3;
  if (this->_internal_dimension() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_dimension(), target);
  }

  // double purity = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_purity = this->_internal_purity();
  uint64_t raw_purity;
  memcpy(&raw_purity, &tmp_purity, sizeof(tmp_purity));
  if (raw_purity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_purity(), target);
  }

  // .brain.MemoryStats memory_stats = 5;
  if (this->_internal_has_memory_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::memory_stats(this),
        _Internal::memory_stats(this).GetCachedSize(), target, stream);
  }

  // .brain.GraphStats graph_stats = 6;
  if (this->_internal_has_graph_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::graph_stats(this),
        _Internal::graph_stats(this).GetCachedSize(), target, stream);
  }

  // map<string, double> metrics = 7;
  if (!this->_internal_metrics().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = StatsResp_MetricsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_metrics();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "brain.StatsResp.MetricsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.StatsResp)
  return target;
}

size_t StatsResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.StatsResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> metrics = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metrics_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_metrics().begin();
      it != this->_internal_metrics().end(); ++it) {
    total_size += StatsResp_MetricsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .brain.MemoryStats memory_stats = 5;
  if (this->_internal_has_memory_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.memory_stats_);
  }

  // .brain.GraphStats graph_stats = 6;
  if (this->_internal_has_graph_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.graph_stats_);
  }

  // double entropy = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = this->_internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    total_size += 1 + 8;
  }

  // int64 total_collapses = 2;
  if (this->_internal_total_collapses() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_collapses());
  }

  // double purity = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_purity = this->_internal_purity();
  uint64_t raw_purity;
  memcpy(&raw_purity, &tmp_purity, sizeof(tmp_purity));
  if (raw_purity != 0) {
    total_size += 1 + 8;
  }

  // int32 dimension = 3;
  if (this->_internal_dimension() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dimension());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsResp::GetClassData() const { return &_class_data_; }


void StatsResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsResp*>(&to_msg);
  auto& from = static_cast<const StatsResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.StatsResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metrics_.MergeFrom(from._impl_.metrics_);
  if (from._internal_has_memory_stats()) {
    _this->_internal_mutable_memory_stats()->::brain::MemoryStats::MergeFrom(
        from._internal_memory_stats());
  }
  if (from._internal_has_graph_stats()) {
    _this->_internal_mutable_graph_stats()->::brain::GraphStats::MergeFrom(
        from._internal_graph_stats());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_entropy = from._internal_entropy();
  uint64_t raw_entropy;
  memcpy(&raw_entropy, &tmp_entropy, sizeof(tmp_entropy));
  if (raw_entropy != 0) {
    _this->_internal_set_entropy(from._internal_entropy());
  }
  if (from._internal_total_collapses() != 0) {
    _this->_internal_set_total_collapses(from._internal_total_collapses());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_purity = from._internal_purity();
  uint64_t raw_purity;
  memcpy(&raw_purity, &tmp_purity, sizeof(tmp_purity));
  if (raw_purity != 0) {
    _this->_internal_set_purity(from._internal_purity());
  }
  if (from._internal_dimension() != 0) {
    _this->_internal_set_dimension(from._internal_dimension());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsResp::CopyFrom(const StatsResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.StatsResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsResp::IsInitialized() const {
  return true;
}

void StatsResp::InternalSwap(StatsResp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metrics_.InternalSwap(&other->_impl_.metrics_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatsResp, _impl_.dimension_)
      + sizeof(StatsResp::_impl_.dimension_)
      - PROTOBUF_FIELD_OFFSET(StatsResp, _impl_.memory_stats_)>(
          reinterpret_cast<char*>(&_impl_.memory_stats_),
          reinterpret_cast<char*>(&other->_impl_.memory_stats_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[6]);
}

// ===================================================================

class EmbedReq::_Internal {
 public:
};

EmbedReq::EmbedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.EmbedReq)
}
EmbedReq::EmbedReq(const EmbedReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmbedReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:brain.EmbedReq)
}

inline void EmbedReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.text_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EmbedReq::~EmbedReq() {
  // @@protoc_insertion_point(destructor:brain.EmbedReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void EmbedReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedReq::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.EmbedReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.EmbedReq.text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbedReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.EmbedReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.EmbedReq.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.EmbedReq)
  return target;
}

size_t EmbedReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.EmbedReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedReq::GetClassData() const { return &_class_data_; }


void EmbedReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedReq*>(&to_msg);
  auto& from = static_cast<const EmbedReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.EmbedReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedReq::CopyFrom(const EmbedReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.EmbedReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedReq::IsInitialized() const {
  return true;
}

void EmbedReq::InternalSwap(EmbedReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[7]);
}

// ===================================================================

class EmbedResp::_Internal {
 public:
};

EmbedResp::EmbedResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.EmbedResp)
}
EmbedResp::EmbedResp(const EmbedResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmbedResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.embedding_){from._impl_.embedding_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.EmbedResp)
}

inline void EmbedResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.embedding_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EmbedResp::~EmbedResp() {
  // @@protoc_insertion_point(destructor:brain.EmbedResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.embedding_.~RepeatedField();
}

void EmbedResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.EmbedResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.embedding_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float embedding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_embedding(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_embedding(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbedResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.EmbedResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float embedding = 1;
  if (this->_internal_embedding_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_embedding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.EmbedResp)
  return target;
}

size_t EmbedResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.EmbedResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float embedding = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_embedding_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedResp::GetClassData() const { return &_class_data_; }


void EmbedResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedResp*>(&to_msg);
  auto& from = static_cast<const EmbedResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.EmbedResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.embedding_.MergeFrom(from._impl_.embedding_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedResp::CopyFrom(const EmbedResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.EmbedResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedResp::IsInitialized() const {
  return true;
}

void EmbedResp::InternalSwap(EmbedResp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.embedding_.InternalSwap(&other->_impl_.embedding_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[8]);
}

// ===================================================================

class UpsertReq::_Internal {
 public:
};

UpsertReq::UpsertReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.UpsertReq)
}
UpsertReq::UpsertReq(const UpsertReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpsertReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){from._impl_.ids_}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.vectors_){from._impl_.vectors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.UpsertReq)
}

inline void UpsertReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){arena}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.vectors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpsertReq::~UpsertReq() {
  // @@protoc_insertion_point(destructor:brain.UpsertReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpsertReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
  _impl_.vectors_.~RepeatedPtrField();
}

void UpsertReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpsertReq::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.UpsertReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _impl_.vectors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpsertReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .brain.EmbedVector vectors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vectors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpsertReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.UpsertReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 ids = 1;
  {
    int byte_size = _impl_._ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_ids(), byte_size, target);
    }
  }

  // repeated .brain.EmbedVector vectors = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vectors_size()); i < n; i++) {
    const auto& repfield = this->_internal_vectors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.UpsertReq)
  return target;
}

size_t UpsertReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.UpsertReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .brain.EmbedVector vectors = 2;
  total_size += 1UL * this->_internal_vectors_size();
  for (const auto& msg : this->_impl_.vectors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpsertReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpsertReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpsertReq::GetClassData() const { return &_class_data_; }


void UpsertReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpsertReq*>(&to_msg);
  auto& from = static_cast<const UpsertReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.UpsertReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_impl_.vectors_.MergeFrom(from._impl_.vectors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpsertReq::CopyFrom(const UpsertReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.UpsertReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpsertReq::IsInitialized() const {
  return true;
}

void UpsertReq::InternalSwap(UpsertReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
  _impl_.vectors_.InternalSwap(&other->_impl_.vectors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpsertReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[9]);
}

// ===================================================================

class EmbedVector::_Internal {
 public:
};

EmbedVector::EmbedVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.EmbedVector)
}
EmbedVector::EmbedVector(const EmbedVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmbedVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.EmbedVector)
}

inline void EmbedVector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EmbedVector::~EmbedVector() {
  // @@protoc_insertion_point(destructor:brain.EmbedVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmbedVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedField();
}

void EmbedVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmbedVector::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.EmbedVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmbedVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmbedVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.EmbedVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1;
  if (this->_internal_data_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.EmbedVector)
  return target;
}

size_t EmbedVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.EmbedVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float data = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_data_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmbedVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmbedVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmbedVector::GetClassData() const { return &_class_data_; }


void EmbedVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmbedVector*>(&to_msg);
  auto& from = static_cast<const EmbedVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.EmbedVector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmbedVector::CopyFrom(const EmbedVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.EmbedVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbedVector::IsInitialized() const {
  return true;
}

void EmbedVector::InternalSwap(EmbedVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmbedVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[10]);
}

// ===================================================================

class UpsertResp::_Internal {
 public:
};

UpsertResp::UpsertResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.UpsertResp)
}
UpsertResp::UpsertResp(const UpsertResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpsertResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:brain.UpsertResp)
}

inline void UpsertResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpsertResp::~UpsertResp() {
  // @@protoc_insertion_point(destructor:brain.UpsertResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpsertResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpsertResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpsertResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.UpsertResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.count_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpsertResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpsertResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.UpsertResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 count = 1;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.UpsertResp)
  return target;
}

size_t UpsertResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.UpsertResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 count = 1;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpsertResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpsertResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpsertResp::GetClassData() const { return &_class_data_; }


void UpsertResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpsertResp*>(&to_msg);
  auto& from = static_cast<const UpsertResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.UpsertResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpsertResp::CopyFrom(const UpsertResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.UpsertResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpsertResp::IsInitialized() const {
  return true;
}

void UpsertResp::InternalSwap(UpsertResp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.count_, other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpsertResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[11]);
}

// ===================================================================

class RecallReq::_Internal {
 public:
};

RecallReq::RecallReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.RecallReq)
}
RecallReq::RecallReq(const RecallReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecallReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.query_){from._impl_.query_}
    , decltype(_impl_.filters_){from._impl_.filters_}
    , decltype(_impl_.topk_){}
    , decltype(_impl_.use_graph_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.topk_, &from._impl_.topk_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_graph_) -
    reinterpret_cast<char*>(&_impl_.topk_)) + sizeof(_impl_.use_graph_));
  // @@protoc_insertion_point(copy_constructor:brain.RecallReq)
}

inline void RecallReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.query_){arena}
    , decltype(_impl_.filters_){arena}
    , decltype(_impl_.topk_){0}
    , decltype(_impl_.use_graph_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecallReq::~RecallReq() {
  // @@protoc_insertion_point(destructor:brain.RecallReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecallReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.query_.~RepeatedField();
  _impl_.filters_.~RepeatedPtrField();
}

void RecallReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecallReq::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.RecallReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.query_.Clear();
  _impl_.filters_.Clear();
  ::memset(&_impl_.topk_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.use_graph_) -
      reinterpret_cast<char*>(&_impl_.topk_)) + sizeof(_impl_.use_graph_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecallReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float query = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_query(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_query(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 topk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.topk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .brain.FilterPredicate filters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool use_graph = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.use_graph_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecallReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.RecallReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float query = 1;
  if (this->_internal_query_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_query(), target);
  }

  // int32 topk = 2;
  if (this->_internal_topk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_topk(), target);
  }

  // repeated .brain.FilterPredicate filters = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_filters_size()); i < n; i++) {
    const auto& repfield = this->_internal_filters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool use_graph = 4;
  if (this->_internal_use_graph() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_use_graph(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.RecallReq)
  return target;
}

size_t RecallReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.RecallReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float query = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_query_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .brain.FilterPredicate filters = 3;
  total_size += 1UL * this->_internal_filters_size();
  for (const auto& msg : this->_impl_.filters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 topk = 2;
  if (this->_internal_topk() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_topk());
  }

  // bool use_graph = 4;
  if (this->_internal_use_graph() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecallReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecallReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecallReq::GetClassData() const { return &_class_data_; }


void RecallReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecallReq*>(&to_msg);
  auto& from = static_cast<const RecallReq&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.RecallReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.query_.MergeFrom(from._impl_.query_);
  _this->_impl_.filters_.MergeFrom(from._impl_.filters_);
  if (from._internal_topk() != 0) {
    _this->_internal_set_topk(from._internal_topk());
  }
  if (from._internal_use_graph() != 0) {
    _this->_internal_set_use_graph(from._internal_use_graph());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecallReq::CopyFrom(const RecallReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.RecallReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecallReq::IsInitialized() const {
  return true;
}

void RecallReq::InternalSwap(RecallReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.query_.InternalSwap(&other->_impl_.query_);
  _impl_.filters_.InternalSwap(&other->_impl_.filters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecallReq, _impl_.use_graph_)
      + sizeof(RecallReq::_impl_.use_graph_)
      - PROTOBUF_FIELD_OFFSET(RecallReq, _impl_.topk_)>(
          reinterpret_cast<char*>(&_impl_.topk_),
          reinterpret_cast<char*>(&other->_impl_.topk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RecallReq::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[12]);
}

// ===================================================================

class FilterPredicate::_Internal {
 public:
};

FilterPredicate::FilterPredicate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.FilterPredicate)
}
FilterPredicate::FilterPredicate(const FilterPredicate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FilterPredicate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.op_){}
    , decltype(_impl_.value_text_){}
    , decltype(_impl_.value_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.op_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.op_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_op().empty()) {
    _this->_impl_.op_.Set(from._internal_op(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value_text().empty()) {
    _this->_impl_.value_text_.Set(from._internal_value_text(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_num_ = from._impl_.value_num_;
  // @@protoc_insertion_point(copy_constructor:brain.FilterPredicate)
}

inline void FilterPredicate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.op_){}
    , decltype(_impl_.value_text_){}
    , decltype(_impl_.value_num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.op_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.op_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FilterPredicate::~FilterPredicate() {
  // @@protoc_insertion_point(destructor:brain.FilterPredicate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilterPredicate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.op_.Destroy();
  _impl_.value_text_.Destroy();
}

void FilterPredicate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilterPredicate::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.FilterPredicate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.op_.ClearToEmpty();
  _impl_.value_text_.ClearToEmpty();
  _impl_.value_num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FilterPredicate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.FilterPredicate.key"));
        } else
          goto handle_unusual;
        continue;
      // string op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_op();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.FilterPredicate.op"));
        } else
          goto handle_unusual;
        continue;
      // string value_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "brain.FilterPredicate.value_text"));
        } else
          goto handle_unusual;
        continue;
      // double value_num = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.value_num_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilterPredicate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.FilterPredicate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.FilterPredicate.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string op = 2;
  if (!this->_internal_op().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_op().data(), static_cast<int>(this->_internal_op().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.FilterPredicate.op");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_op(), target);
  }

  // string value_text = 3;
  if (!this->_internal_value_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value_text().data(), static_cast<int>(this->_internal_value_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "brain.FilterPredicate.value_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value_text(), target);
  }

  // double value_num = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value_num = this->_internal_value_num();
  uint64_t raw_value_num;
  memcpy(&raw_value_num, &tmp_value_num, sizeof(tmp_value_num));
  if (raw_value_num != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_value_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.FilterPredicate)
  return target;
}

size_t FilterPredicate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.FilterPredicate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string op = 2;
  if (!this->_internal_op().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_op());
  }

  // string value_text = 3;
  if (!this->_internal_value_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value_text());
  }

  // double value_num = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value_num = this->_internal_value_num();
  uint64_t raw_value_num;
  memcpy(&raw_value_num, &tmp_value_num, sizeof(tmp_value_num));
  if (raw_value_num != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FilterPredicate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FilterPredicate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FilterPredicate::GetClassData() const { return &_class_data_; }


void FilterPredicate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FilterPredicate*>(&to_msg);
  auto& from = static_cast<const FilterPredicate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.FilterPredicate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_op().empty()) {
    _this->_internal_set_op(from._internal_op());
  }
  if (!from._internal_value_text().empty()) {
    _this->_internal_set_value_text(from._internal_value_text());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value_num = from._internal_value_num();
  uint64_t raw_value_num;
  memcpy(&raw_value_num, &tmp_value_num, sizeof(tmp_value_num));
  if (raw_value_num != 0) {
    _this->_internal_set_value_num(from._internal_value_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FilterPredicate::CopyFrom(const FilterPredicate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.FilterPredicate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterPredicate::IsInitialized() const {
  return true;
}

void FilterPredicate::InternalSwap(FilterPredicate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.op_, lhs_arena,
      &other->_impl_.op_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_text_, lhs_arena,
      &other->_impl_.value_text_, rhs_arena
  );
  swap(_impl_.value_num_, other->_impl_.value_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FilterPredicate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[13]);
}

// ===================================================================

class RecallResp::_Internal {
 public:
};

RecallResp::RecallResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.RecallResp)
}
RecallResp::RecallResp(const RecallResp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecallResp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){from._impl_.ids_}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.distances_){from._impl_.distances_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brain.RecallResp)
}

inline void RecallResp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){arena}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , decltype(_impl_.distances_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecallResp::~RecallResp() {
  // @@protoc_insertion_point(destructor:brain.RecallResp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecallResp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
  _impl_.distances_.~RepeatedField();
}

void RecallResp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecallResp::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.RecallResp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _impl_.distances_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecallResp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float distances = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_distances(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_distances(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecallResp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.RecallResp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 ids = 1;
  {
    int byte_size = _impl_._ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_ids(), byte_size, target);
    }
  }

  // repeated float distances = 2;
  if (this->_internal_distances_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_distances(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.RecallResp)
  return target;
}

size_t RecallResp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.RecallResp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated float distances = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_distances_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecallResp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecallResp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecallResp::GetClassData() const { return &_class_data_; }


void RecallResp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecallResp*>(&to_msg);
  auto& from = static_cast<const RecallResp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.RecallResp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_impl_.distances_.MergeFrom(from._impl_.distances_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecallResp::CopyFrom(const RecallResp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.RecallResp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecallResp::IsInitialized() const {
  return true;
}

void RecallResp::InternalSwap(RecallResp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
  _impl_.distances_.InternalSwap(&other->_impl_.distances_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecallResp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[14]);
}

// ===================================================================

class MemoryStats::_Internal {
 public:
};

MemoryStats::MemoryStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.MemoryStats)
}
MemoryStats::MemoryStats(const MemoryStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MemoryStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.total_items_){}
    , decltype(_impl_.hot_items_){}
    , decltype(_impl_.warm_items_){}
    , decltype(_impl_.cold_items_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.total_items_, &from._impl_.total_items_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cold_items_) -
    reinterpret_cast<char*>(&_impl_.total_items_)) + sizeof(_impl_.cold_items_));
  // @@protoc_insertion_point(copy_constructor:brain.MemoryStats)
}

inline void MemoryStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.total_items_){int64_t{0}}
    , decltype(_impl_.hot_items_){int64_t{0}}
    , decltype(_impl_.warm_items_){int64_t{0}}
    , decltype(_impl_.cold_items_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MemoryStats::~MemoryStats() {
  // @@protoc_insertion_point(destructor:brain.MemoryStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MemoryStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MemoryStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MemoryStats::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.MemoryStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.total_items_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cold_items_) -
      reinterpret_cast<char*>(&_impl_.total_items_)) + sizeof(_impl_.cold_items_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MemoryStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 total_items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.total_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 hot_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.hot_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 warm_items = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.warm_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 cold_items = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.cold_items_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MemoryStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.MemoryStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 total_items = 1;
  if (this->_internal_total_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_total_items(), target);
  }

  // int64 hot_items = 2;
  if (this->_internal_hot_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_hot_items(), target);
  }

  // int64 warm_items = 3;
  if (this->_internal_warm_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_warm_items(), target);
  }

  // int64 cold_items = 4;
  if (this->_internal_cold_items() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_cold_items(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.MemoryStats)
  return target;
}

size_t MemoryStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.MemoryStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 total_items = 1;
  if (this->_internal_total_items() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_items());
  }

  // int64 hot_items = 2;
  if (this->_internal_hot_items() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hot_items());
  }

  // int64 warm_items = 3;
  if (this->_internal_warm_items() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warm_items());
  }

  // int64 cold_items = 4;
  if (this->_internal_cold_items() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_cold_items());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MemoryStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MemoryStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MemoryStats::GetClassData() const { return &_class_data_; }


void MemoryStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MemoryStats*>(&to_msg);
  auto& from = static_cast<const MemoryStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.MemoryStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_total_items() != 0) {
    _this->_internal_set_total_items(from._internal_total_items());
  }
  if (from._internal_hot_items() != 0) {
    _this->_internal_set_hot_items(from._internal_hot_items());
  }
  if (from._internal_warm_items() != 0) {
    _this->_internal_set_warm_items(from._internal_warm_items());
  }
  if (from._internal_cold_items() != 0) {
    _this->_internal_set_cold_items(from._internal_cold_items());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MemoryStats::CopyFrom(const MemoryStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.MemoryStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryStats::IsInitialized() const {
  return true;
}

void MemoryStats::InternalSwap(MemoryStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MemoryStats, _impl_.cold_items_)
      + sizeof(MemoryStats::_impl_.cold_items_)
      - PROTOBUF_FIELD_OFFSET(MemoryStats, _impl_.total_items_)>(
          reinterpret_cast<char*>(&_impl_.total_items_),
          reinterpret_cast<char*>(&other->_impl_.total_items_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MemoryStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[15]);
}

// ===================================================================

class GraphStats::_Internal {
 public:
};

GraphStats::GraphStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brain.GraphStats)
}
GraphStats::GraphStats(const GraphStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GraphStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){}
    , decltype(_impl_.edges_){}
    , decltype(_impl_.avg_degree_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.nodes_, &from._impl_.nodes_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.avg_degree_) -
    reinterpret_cast<char*>(&_impl_.nodes_)) + sizeof(_impl_.avg_degree_));
  // @@protoc_insertion_point(copy_constructor:brain.GraphStats)
}

inline void GraphStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){int64_t{0}}
    , decltype(_impl_.edges_){int64_t{0}}
    , decltype(_impl_.avg_degree_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GraphStats::~GraphStats() {
  // @@protoc_insertion_point(destructor:brain.GraphStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GraphStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GraphStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GraphStats::Clear() {
// @@protoc_insertion_point(message_clear_start:brain.GraphStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.nodes_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.avg_degree_) -
      reinterpret_cast<char*>(&_impl_.nodes_)) + sizeof(_impl_.avg_degree_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GraphStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.nodes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 edges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.edges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double avg_degree = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.avg_degree_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GraphStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brain.GraphStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 nodes = 1;
  if (this->_internal_nodes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_nodes(), target);
  }

  // int64 edges = 2;
  if (this->_internal_edges() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_edges(), target);
  }

  // double avg_degree = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_degree = this->_internal_avg_degree();
  uint64_t raw_avg_degree;
  memcpy(&raw_avg_degree, &tmp_avg_degree, sizeof(tmp_avg_degree));
  if (raw_avg_degree != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_avg_degree(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brain.GraphStats)
  return target;
}

size_t GraphStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brain.GraphStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 nodes = 1;
  if (this->_internal_nodes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nodes());
  }

  // int64 edges = 2;
  if (this->_internal_edges() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_edges());
  }

  // double avg_degree = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_degree = this->_internal_avg_degree();
  uint64_t raw_avg_degree;
  memcpy(&raw_avg_degree, &tmp_avg_degree, sizeof(tmp_avg_degree));
  if (raw_avg_degree != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GraphStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GraphStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GraphStats::GetClassData() const { return &_class_data_; }


void GraphStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GraphStats*>(&to_msg);
  auto& from = static_cast<const GraphStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:brain.GraphStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_nodes() != 0) {
    _this->_internal_set_nodes(from._internal_nodes());
  }
  if (from._internal_edges() != 0) {
    _this->_internal_set_edges(from._internal_edges());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_avg_degree = from._internal_avg_degree();
  uint64_t raw_avg_degree;
  memcpy(&raw_avg_degree, &tmp_avg_degree, sizeof(tmp_avg_degree));
  if (raw_avg_degree != 0) {
    _this->_internal_set_avg_degree(from._internal_avg_degree());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GraphStats::CopyFrom(const GraphStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brain.GraphStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GraphStats::IsInitialized() const {
  return true;
}

void GraphStats::InternalSwap(GraphStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GraphStats, _impl_.avg_degree_)
      + sizeof(GraphStats::_impl_.avg_degree_)
      - PROTOBUF_FIELD_OFFSET(GraphStats, _impl_.nodes_)>(
          reinterpret_cast<char*>(&_impl_.nodes_),
          reinterpret_cast<char*>(&other->_impl_.nodes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GraphStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brain_2eproto_getter, &descriptor_table_brain_2eproto_once,
      file_level_metadata_brain_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace brain
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::brain::HealthReq*
Arena::CreateMaybeMessage< ::brain::HealthReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::HealthReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::HealthResp*
Arena::CreateMaybeMessage< ::brain::HealthResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::HealthResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::StepReq*
Arena::CreateMaybeMessage< ::brain::StepReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::StepReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::StepResp*
Arena::CreateMaybeMessage< ::brain::StepResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::StepResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::StatsReq*
Arena::CreateMaybeMessage< ::brain::StatsReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::StatsReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::StatsResp_MetricsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::brain::StatsResp_MetricsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::StatsResp_MetricsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::StatsResp*
Arena::CreateMaybeMessage< ::brain::StatsResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::StatsResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::EmbedReq*
Arena::CreateMaybeMessage< ::brain::EmbedReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::EmbedReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::EmbedResp*
Arena::CreateMaybeMessage< ::brain::EmbedResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::EmbedResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::UpsertReq*
Arena::CreateMaybeMessage< ::brain::UpsertReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::UpsertReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::EmbedVector*
Arena::CreateMaybeMessage< ::brain::EmbedVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::EmbedVector >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::UpsertResp*
Arena::CreateMaybeMessage< ::brain::UpsertResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::UpsertResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::RecallReq*
Arena::CreateMaybeMessage< ::brain::RecallReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::RecallReq >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::FilterPredicate*
Arena::CreateMaybeMessage< ::brain::FilterPredicate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::FilterPredicate >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::RecallResp*
Arena::CreateMaybeMessage< ::brain::RecallResp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::RecallResp >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::MemoryStats*
Arena::CreateMaybeMessage< ::brain::MemoryStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::MemoryStats >(arena);
}
template<> PROTOBUF_NOINLINE ::brain::GraphStats*
Arena::CreateMaybeMessage< ::brain::GraphStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brain::GraphStats >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
